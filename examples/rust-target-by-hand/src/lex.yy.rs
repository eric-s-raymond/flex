/* A lexical scanner generated by flex */
/* START of m4 controls */
/* M4_YY_TABLES_VERIFY = 0 */
/* M4_YY_REENTRANT */
/* YY_MAIN = 1 */
/* M4_MODE_NO_DO_STDINIT */
/* M4_MODE_NO_YYTEXT_IS_ARRAY */
/* M4_MODE_NO_YYMORE_USED */
/* M4_MODE_NO_REAL_FULLSPD */
/* M4_MODE_NO_REAL_FULLTBL */
/* M4_MODE_NO_CPP_USE_READ */
/* M4_MODE_NO_VARIABLE_TRAILING_CONTEXT_RULES */
/* M4_MODE_FIND_ACTION_REJECT_REALLY_USED */
/* M4_MODE_NO_USES_REJECT */
/* M4_MODE_USEMECS */
/* M4_MODE_FIND_ACTION_COMPRESSED */
/* M4_MODE_NO_FULLSPD */
/* M4_MODE_NO_BOL_NEEDED */
/* M4_MODE_USEECS */
/* M4_MODE_GENTABLES */
/* M4_MODE_INTERACTIVE */
/* M4_MODE_NO_FULLSPD_OR_FULLTBL */
/* M4_MODE_FIND_ACTION_REJECT_OR_INTERACTIVE */
/* M4_MODE_NO_YYWRAP */
/* M4_MODE_INTERACTIVE */
/* M4_MODE_C_ONLY */
/* M4_MODE_PREFIX = yy */
/* END of m4 controls */

use std::io;
use std::ptr;
use std::rc::Rc;
use std::cell::RefCell;

const FLEX_SCANNER: bool = true;
const MAJOR_VERSION: usize = 2;
const MINOR_VERSION: usize = 6;
const SUBMINOR_VERSION: usize = 4;
const FLEX_BETA: bool = SUBMINOR_VERSION > 0;

type Result<T> = std::result::Result<T, &'static str>;

#[derive(Default)]
pub struct Scanner<T> {
    /// User-defined. Not touched by flex.
    extra: Option<T>,

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    pub input: Option<Rc<RefCell<dyn io::Read>>>,
    output: Option<Box<dyn io::Write>>,
    /// Stack as an array.
    buffer_stack: Vec<BufferState>,
    hold_char: u8,
    n_chars: usize,
    length: usize,
    c_buf_p: usize,
    init: bool,
    start: State,
    did_buffer_switch_on_eof: bool,
    start_stack_ptr: usize,
    start_stack_depth: usize,
    start_stack: Vec<usize>,
    last_accepting_state: State,
    last_accepting_cpos: usize,

    lineno: usize,
    flex_debug: usize,

    text: usize,
    more_flag: usize,
    more_len: usize,
}

impl<T: Default> Scanner<T> {
    pub fn new() -> Self {
        let mut s: Scanner<T> = Default::default();
        s.init(true);
        s
    }
}

impl<T> Scanner<T> {
    fn init(&mut self, stdinit: bool) {
        self.buffer_stack = Vec::new();
        self.c_buf_p = 0;
        self.init = false;
        self.start = 0;

        self.start_stack = Vec::new();
        self.start_stack_depth = 0;

        if stdinit {
            self.input = Some(Rc::new(RefCell::new(io::stdin())));
            self.output = Some(Box::new(io::stdout()));
        }
    }

    /** We provide macros for accessing buffer states in case in the
     * future we want to put the buffer states in a more general
     * "scanner state".
     *
     * Returns the top of the stack, or NULL.
     */
    fn current_buffer(&self) -> Option<&BufferState> {
        self.buffer_stack.last()
    }

    fn current_buffer_mut(&mut self) -> Option<&mut BufferState> {
        self.buffer_stack.last_mut()
    }

    /** Same as current_buffer, but useful when we know that the buffer
     * stack is not None. For internal use only.
     */
    fn current_buffer_unchecked(&self) -> &BufferState {
        self.buffer_stack.last().expect("stack should not be empty")
    }

    fn current_buffer_unchecked_mut(&mut self) -> &mut BufferState {
        self.buffer_stack.last_mut().expect("stack should not be empty")
    }

    pub fn set_interactive(&mut self, is_interactive: bool) {
        if self.buffer_stack.is_empty() {
            self.push_new_buffer(self.input.clone(), BUF_SIZE);
        }
        if let Some(buf) = self.current_buffer_mut() {
            buf.is_interactive = is_interactive;
        }
    }

    pub fn set_bol(&mut self, at_bol: bool) {
        if self.buffer_stack.is_empty() {
            self.push_new_buffer(self.input.clone(), BUF_SIZE);
        }
        if let Some(buf) = self.current_buffer_mut() {
            buf.at_bol = at_bol;
        }
    }

    fn at_bol(&self) -> bool {
        match self.current_buffer().map(|buf| buf.at_bol) {
            Some(v) => v,
            None => false,
        }
    }

    /** Done after the current pattern has been matched and before the
      * corresponding action - sets up text.
      */
    fn do_before_action(&mut self, bp: usize, cp: usize) {
        self.text = bp;
        self.length = cp - bp;
        self.hold_char = self.current_buffer_unchecked().ch_buf[cp];
        self.current_buffer_unchecked_mut().ch_buf[cp] = b'\0';
        //self.c_buf_p = cp;
    }

    /** Gets input and stuffs it into "buf".  Returns number of
      * characters read.
      */
    fn read(&mut self, offset: usize, max_size: usize) -> Result<usize> {
        if let Some(file) = &self.input.clone() {
            let buf = self.current_buffer_unchecked_mut();
            buf.ch_buf.truncate(offset);
            buf.ch_buf.resize(max_size + offset, END_OF_BUFFER_CHAR);
            let reader = if buf.is_interactive { read_interactive } else { read_file };
            let bytes = reader(buf, file, offset, max_size)?;
            buf.ch_buf.truncate(bytes + offset);
            Ok(bytes)
        } else {
            Err("read called with no open input file")
        }
    }

    /** The main scanner function which does all the work.
     */
    // YY_DECL {
    pub fn lex<D>(&mut self, _user_data: &mut D) -> Result<()> {
        if !self.init {
            self.init = true;

            // YY_USER_INIT

            if self.start == 0 {
                self.start = 1; // first start state
            }
            self.push_new_buffer(self.input.clone(), BUF_SIZE);

            self.load_buffer_state();
        }

        // open scope of user declarations
        {
            let mut cc: usize = 0;
            let mut wc: usize = 0;
            let mut lc: usize = 0;

            loop {
                /* loops until end-of-file is reached */
                let mut cp: usize = self.c_buf_p;
                // bp points to the position in ch_buf of the start of the current run.
                let mut bp: usize = cp;

                // Support of text.
                self.current_buffer_unchecked_mut().ch_buf[cp] = self.hold_char;

                // Generate the code to find the start state.

                let mut current_state: State = self.start;

                // Set up for storing up states.

                // Generate the code to find the next match.

                'matcher: loop {
                    loop {
                        let mut c: u8 = ec[self.current_buffer_unchecked().ch_buf[cp as usize] as usize];
                        // Save the backing-up info \before/ computing the next state because we
                        // always compute one more state than needed - we always proceed until we
                        // reach a jam state

                        // Generate code to keep backing-up information.

                        if accept[current_state as usize] != 0 {
                            self.last_accepting_state = current_state;
                            self.last_accepting_cpos = cp;
                        }

                        while chk[base[current_state as usize] as usize + c as usize] != current_state {
                            current_state = def[current_state as usize];

                            // We've arranged it so that templates are never chained to one another.
                            // This means we can afford to make a very simple test to see if we need
                            // to convert to c's meta-equivalence class without worrying about
                            // erroneously looking up the meta-equivalence class twice

                            // lastdfa + 2 == JAMSTATE + 1 is the beginning of the templates
                            if current_state > JAMSTATE + 1 {
                                c = meta[c as usize];
                            }
                        }

                        current_state = nxt[base[current_state as usize] as usize + c as usize];

                        cp += 1;

                        if base[current_state as usize] == JAMBASE {
                            break;
                        }
                    }

                    'find_action: loop {
                        // code to find the action number goes here

                        let mut act = accept[current_state as usize];
                        if act == 0 {
                            // have to back up
                            cp = self.last_accepting_cpos;
                            current_state = self.last_accepting_state;
                            act = accept[current_state as usize];
                        }

                        // YY_DO_BEFORE_ACTION
                        self.text = bp;
                        self.length = cp - bp;
                        self.hold_char = self.current_buffer_unchecked().ch_buf[cp];
                        self.current_buffer_unchecked_mut().ch_buf[cp] = b'\0';
                        self.c_buf_p = cp;

                        'do_action: loop {
                            match act {
                                0 => { // must back up
                                    // undo the effects of YY_DO_BEFORE_ACTION
                                    self.current_buffer_unchecked_mut().ch_buf[cp] = self.hold_char;

                                    // Backing-up info for compressed tables is taken \after/ cp
                                    // has been incremented for the next state.

                                    cp = self.last_accepting_cpos;

                                    current_state = self.last_accepting_state;
                                    continue 'find_action;
                                },

                                1 => {
                                    // YY_RULE_SETUP
                                    cc += self.length;
                                    wc += 1;
                                },

                                2 => {
                                    // YY_RULE_SETUP
                                    cc += self.length;
                                },

                                3 => {
                                    // rule 3 can match eol
                                    // YY_RULE_SETUP
                                    lc += 1;
                                    cc += 1;
                                },

                                s if s == END_OF_BUFFER + INITIAL + 1 => {
                                    println!("{:8} {:8} {:8}", lc, wc, cc);
                                    return Ok(());
                                }

                                4 => {
                                    // YY_RULE_SETUP
                                    let start = self.text;
                                    let end = self.text + self.length;
                                    let buf = self.current_buffer_unchecked().ch_buf[start..end].to_vec();
                                    if let Some(out) = &mut self.output {
                                        out.as_mut().write(&buf[..]).expect("write failure");
                                    }
                                }

                                s if s == END_OF_BUFFER => {
                                    // Amount of text matched not including the EOB char.
                                    let amount_of_matched_text = cp - self.text - 1;

                                    // Undo the effects of YY_DO_BEFORE_ACTION.
                                    self.current_buffer_unchecked_mut().ch_buf[cp] = self.hold_char;
                                    // YY_RESTORE_YY_MORE_OFFSET

                                    if self.current_buffer_unchecked().buffer_status == BufferStatus::New {
                                        // We're scanning a new file or input source.  It's possible
                                        // that this happened because the user just pointed in at
                                        // a new source and called lex().  If so, then we have to
                                        // assure consistency between CURRENT_BUFFER and our
                                        // globals.  Here is the right place to do so, because this
                                        // is the first action (other than possibly a back-up) that
                                        // will match for the new input source.
                                        self.n_chars = self.current_buffer_unchecked().n_chars;
                                        self.current_buffer_unchecked_mut().input_file = self.input.clone();
                                        self.current_buffer_unchecked_mut().buffer_status = BufferStatus::Normal;
                                    }

                                    // Note that here we test for c_buf_p "<=" to the position of
                                    // the first EOB in the buffer, since c_buf_p will already
                                    // have been incremented past the NUL character (since all
                                    // states make transitions on EOB to the end-of-buffer state).
                                    // Contrast this with the test in input().
                                    if self.c_buf_p <= self.n_chars { /* This was really a NUL. */
                                        self.c_buf_p = self.text + amount_of_matched_text;

                                        current_state = self.get_previous_state();

                                        // Okay, we're now positioned to make the NUL transition.
                                        // we couldn't have get_previous_state() go ahead and do
                                        // it for us because it doesn't know how to deal with the
                                        // possibility of jamming (and we don't want to build
                                        // jamming into it because then it will run more slowly).
                                        let next_state = self.try_NUL_trans(current_state);

                                        bp = self.text + MORE_ADJ;

                                        if next_state != 0 {
                                            // Consume the NUL
                                            self.c_buf_p += 1;
                                            cp = self.c_buf_p + 1;
                                            current_state = next_state;
                                            continue 'matcher;
                                        } else {
                                            // Still need to initialize cp, though
                                            // current_state was set up by
                                            // get_previous_state().
                                            cp = self.c_buf_p;
                                            continue 'find_action;
                                        }
                                    } else {
                                        // not a NUL
                                        match self.get_next_buffer()? {
                                            Some(EOBAction::EndOfFile) => {
                                                self.did_buffer_switch_on_eof = false;

                                                if self.wrap() {
                                                    // Note: because we've taken care in
                                                    // get_next_buffer() to have set up text,
                                                    // we can now set up c_buf_p so that if some
                                                    // total hoser (like flex itself) wants to call
                                                    // the scanner after we return the NULL,
                                                    // it'll still work - another NULL will get
                                                    // returned.
                                                    self.c_buf_p = self.text + MORE_ADJ;

                                                    act = END_OF_BUFFER + ((self.start - 1) / 2) + 1;
                                                    continue 'do_action;
                                                } else {
                                                    if !self.did_buffer_switch_on_eof {
                                                        // YY_NEW_FILE;
                                                        self.restart(self.input.clone());
                                                    }
                                                }
                                            }

                                            Some(EOBAction::ContinueScan) => {
                                                self.c_buf_p = self.text + amount_of_matched_text;

                                                current_state = self.get_previous_state();

                                                cp = self.c_buf_p;
                                                bp = self.text + MORE_ADJ;
                                                continue 'matcher;
                                            }

                                            Some(EOBAction::LastMatch) => {
                                                self.c_buf_p = self.n_chars;

                                                current_state = self.get_previous_state();

                                                cp = self.c_buf_p;
                                                bp = self.text + MORE_ADJ;
                                                continue 'find_action;
                                            }

                                            None => {
                                                // take no action? get_next_buffer says that it
                                                // wants to "force" the EOB, but it's hard to see
                                                // what that means at the moment.
                                            }
                                        }
                                    }
                                }

                                _ => {
                                    return Err("fatal flex scanner internal error--no action found");
                                }
                            }
                            break;
                        }
                        break;
                    }

                    break 'matcher;
                }
            }
        }
    }

    /* get_next_buffer - try to read in a new buffer
     *
     * Returns a code representing an action:
     *	EOB_ACT_LAST_MATCH -
     *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
     *	EOB_ACT_END_OF_FILE - end of file
     */
    fn get_next_buffer(&mut self) -> Result<Option<EOBAction>> {
        if self.c_buf_p > self.n_chars + 1 {
            Err("fatal flex scanner internal error--end of buffer missed")
        } else if !self.current_buffer_unchecked().fill_buffer {
            // Don't try to fill the buffer, so this is an EOF.
            if self.c_buf_p - self.text - MORE_ADJ == 1 {
                // We matched a single character, the EOB, so treat this as a final EOF.
                Ok(Some(EOBAction::EndOfFile))
            } else {
                // We matched some text prior to the EOB, first process it.
                Ok(Some(EOBAction::LastMatch))
            }
        } else {
            // Try to read more data.
            // First move last chars to start of buffer.
            let number_to_move = self.c_buf_p - self.text - 1;
            let range = self.text..self.c_buf_p-1;
            self.current_buffer_unchecked_mut().ch_buf.copy_within(range, 0);
            if self.current_buffer_unchecked().buffer_status == BufferStatus::EOFPending {
                // don't do the read, it's not guaranteed to return an EOF, just force an EOF
                self.current_buffer_unchecked_mut().n_chars = 0;
                self.n_chars = 0;
            } else {
                let mut num_to_read = self.current_buffer_unchecked().buf_size - number_to_move - 1;
                if num_to_read > READ_BUF_SIZE {
                    num_to_read = READ_BUF_SIZE;
                }
                // Include room in for 2 EOB chars.
                self.current_buffer_unchecked_mut().ch_buf.reserve(num_to_read + 2);
                self.n_chars = self.read(number_to_move, num_to_read)?;
                self.current_buffer_unchecked_mut().n_chars = self.n_chars;
                self.n_chars += number_to_move;
            }

            self.current_buffer_unchecked_mut().ch_buf.extend_from_slice(&[END_OF_BUFFER_CHAR, END_OF_BUFFER_CHAR]);
            self.text = 0;

            if self.n_chars == 0 {
                if number_to_move == MORE_ADJ {
                    let source = self.input.clone();
                    self.restart(source);
                    Ok(Some(EOBAction::EndOfFile))
                } else {
                    self.current_buffer_unchecked_mut().buffer_status = BufferStatus::EOFPending;
                    Ok(Some(EOBAction::LastMatch))
                }
            } else {
                Ok(Some(EOBAction::ContinueScan))
            }
        }
    }

    /// get the state just before the EOB char was reached
    fn get_previous_state(&mut self) -> State {
        let mut current_state = self.start;
        // Set up for storing up states.
        for cp in self.text + MORE_ADJ .. self.c_buf_p {
            // Generate the code to find the next state.
            let mut c: u8 = if self.current_buffer_unchecked().ch_buf[cp] == 0 {
                NUL_EC
            } else {
                ec[self.current_buffer_unchecked().ch_buf[cp as usize] as usize]
            };

            // Save the backing-up info \before/ computing the next state because we always compute
            // one more state than needed - we always proceed until we reach a jam state

            // Generate code to keep backing-up information.

            if accept[current_state as usize] != 0 {
                self.last_accepting_state = current_state;
                self.last_accepting_cpos = cp;
            }

            while chk[base[current_state as usize] as usize + c as usize] != current_state {
                current_state = def[current_state as usize];

                // We've arranged it so that templates are never chained to one another.  This means
                // we can afford to make a very simple test to see if we need to convert to c's
                // meta-equivalence class without worrying about erroneously looking up the
                // meta-equivalence class twice.

                // lastdfa + 2 == JAMSTATE + 1 is the beginning of the templates
                if current_state > JAMSTATE + 1 {
                    c = meta[c as usize];
                }
            }
            current_state = nxt[base[current_state as usize] as usize + c as usize];
        }
        current_state
    }

    /// try to make a transition on the NUL character
    ///
    /// synopsis
    ///   next_state = try_NUL_trans( current_state );
    fn try_NUL_trans(&mut self, current_state: State) -> State {
        let mut current_state = current_state;
        // Generate code for handling NUL's, if needed.

        // First, deal with backing up and setting up cp if the scanner finds that it should JAM
        // on the NUL.
        //
        // Only generate a definition for "cp" if we'll generate code that uses it.  Otherwise
        // lint and the like complain.
        let cp = self.c_buf_p;

        let mut c = NUL_EC;
        // Save the backing-up info \before/ computing the next state because we always compute one
        // more state than needed - we always proceed until we reach a jam state

        // Generate code to keep backing-up information.

        if accept[current_state as usize] != 0 {
            self.last_accepting_state = current_state;
            self.last_accepting_cpos = cp;
        }
        while chk[base[current_state as usize] as usize + c as usize] != current_state {
            current_state = def[current_state as usize];

            // We've arranged it so that templates are never chained to one another.  This means we
            // can afford to make a very simple test to see if we need to convert to c's
            // meta-equivalence class without worrying about erroneously looking up the
            // meta-equivalence class twice

            // lastdfa + 2 == JAMSTATE + 1 is the beginning of the templates
            if current_state > JAMSTATE {
                c = meta[c as usize];
            }
        }
        current_state = nxt[base[current_state as usize] as usize + c as usize];
        let is_jam = current_state == JAMSTATE;
        if is_jam { 0 } else { current_state }
    }

    fn unput(&mut self, c: u8, bp: usize) {
        let mut cp = self.c_buf_p;
        // undo effects of setting up text
        self.current_buffer_unchecked_mut().ch_buf[cp] = self.hold_char;
        // TODO(db48x): this code originally said "need to shift things up to make room +2 for EOB
        // chars."; might need to put that back in.
        if cp == 0 {
            self.current_buffer_unchecked_mut().ch_buf.insert(0, c);
        } else {
            cp -= 1;
            self.current_buffer_unchecked_mut().ch_buf[cp] = c;
        }
        self.text = bp;
        self.hold_char = self.current_buffer_unchecked().ch_buf[cp];
        self.c_buf_p = cp;
    }

    fn input(&mut self) -> Result<u8> {
        let p = self.c_buf_p;
        self.current_buffer_unchecked_mut().ch_buf[p] = self.hold_char;

        if self.current_buffer_unchecked().ch_buf[self.c_buf_p] == END_OF_BUFFER_CHAR {
            // c_buf_p now points to the character we want to return.  If this occurs *before*
            // the EOB characters, then it's a valid NUL; if not, then we've hit the end of the
            // buffer.
            if self.c_buf_p < self.n_chars {
                // This was really a NUL.
                let p = self.c_buf_p;
                self.current_buffer_unchecked_mut().ch_buf[p] = b'\0';
            } else {
                // need more input
                let offset = self.c_buf_p - self.text;
                self.c_buf_p += 1;

                match self.get_next_buffer()? {
                    Some(EOBAction::LastMatch) => {
                        // This happens because g_n_b() sees that we've accumulated a token and
                        // flags that we need to try matching the token before proceeding.  But for
                        // input(), there's no matching to consider.  So convert the
                        // EOB_ACT_LAST_MATCH to EOB_ACT_END_OF_FILE.

                        // Reset buffer status.
                        self.restart(self.input.clone());

                        if self.wrap() {
                            return Ok(b'\0');
                        }
                        if !self.did_buffer_switch_on_eof {
                            // YY_NEW_FILE
                            self.restart(self.input.clone());
                        }
                        return self.input();
                    }

                    Some(EOBAction::EndOfFile) => {
                        if self.wrap() {
                            return Ok(b'\0');
                        }
                        if !self.did_buffer_switch_on_eof {
                            // YY_NEW_FILE
                            self.restart(self.input.clone());
                        }
                        return self.input();
                    }

                    Some(EOBAction::ContinueScan) => {
                        self.c_buf_p = self.text + offset;
                    }

                    None => { unreachable!(); }
                }
            }
        }

        let c = self.current_buffer_unchecked().ch_buf[self.c_buf_p];
        let p = self.c_buf_p;
        self.current_buffer_unchecked_mut().ch_buf[p] = b'\0';
        self.c_buf_p += 1;
        self.hold_char = self.current_buffer_unchecked().ch_buf[self.c_buf_p];
        Ok(c)
    }

    /// Immediately switch to a different input stream.  This function does not reset the start condition
    /// to @c INITIAL .
    fn restart(&mut self, source: Option<Rc<RefCell<dyn io::Read>>>) {
        if self.current_buffer().is_none() {
            self.push_new_buffer(self.input.clone(), BUF_SIZE);
        }
        self.current_buffer_unchecked_mut().init(source);
        // If b is the current buffer, then init_buffer was _probably_ called from restart() or
        // through get_next_buffer.  In that case, we don't want to reset the lineno or column.
        self.current_buffer_unchecked_mut().bs_lineno = 1;
        self.current_buffer_unchecked_mut().bs_column = 0;
        self.load_buffer_state();
    }

    /// Switch to a different input buffer.
    fn switch_to_buffer(&mut self, new_buffer: BufferState) {
        // TODO. We should be able to replace this entire function body with
        //      pop_buffer_state();
        //      push_buffer_state(new_buffer);
        if ptr::eq(self.current_buffer_unchecked(), &new_buffer) {
            if self.current_buffer().is_some() {
                // Flush out information for old buffer.
                let p = self.c_buf_p;
                self.current_buffer_unchecked_mut().ch_buf[p] = self.hold_char;
                self.current_buffer_unchecked_mut().buf_pos = self.c_buf_p;
                self.current_buffer_unchecked_mut().n_chars = self.n_chars;
            }
            *self.current_buffer_unchecked_mut() = new_buffer;
            self.load_buffer_state();

            // We don't actually know whether we did this switch during EOF (wrap()) processing,
            // but the only time this flag is looked at is after wrap() is called, so it's safe to
            // go ahead and always set it.
            self.did_buffer_switch_on_eof = true;
        }
    }

    fn load_buffer_state(&mut self) {
        self.n_chars = self.current_buffer_unchecked().n_chars;
        self.text = self.current_buffer_unchecked().buf_pos;
        self.c_buf_p = self.current_buffer_unchecked().buf_pos;
        self.input = self.current_buffer_unchecked().input_file.clone();
        self.hold_char = self.current_buffer_unchecked().ch_buf[self.c_buf_p];
    }

    fn push_new_buffer(&mut self, source: Option<Rc<RefCell<dyn io::Read>>>, size: usize) {
        let buf = BufferState::new(source, size);
        self.push_buffer_state(buf)
    }

    /// Pushes the new state onto the stack. The new state becomes the current state. This function will
    /// allocate the stack if necessary.
    fn push_buffer_state(&mut self, new_buffer: BufferState) {
        if self.current_buffer().is_some() {
            // Flush out information for old buffer.
            let p = self.c_buf_p;
            self.current_buffer_unchecked_mut().ch_buf[p] = self.hold_char;
            self.current_buffer_unchecked_mut().buf_pos = self.c_buf_p;
            self.current_buffer_unchecked_mut().n_chars = self.n_chars;
        }

        self.buffer_stack.push(new_buffer);
        // copied from switch_to_buffer.
        self.load_buffer_state();
        self.did_buffer_switch_on_eof = true;
    }

    // Removes and deletes the top of the stack, if present.  The next element becomes the new top.
    fn pop_buffer_state(&mut self) {
        self.buffer_stack.pop();
        if !self.buffer_stack.is_empty() {
            self.load_buffer_state();
            self.did_buffer_switch_on_eof = true;
        }
    }

    fn wrap(&mut self) -> bool {
        true
    }

    // Setup the input buffer state to scan directly from a user-specified character buffer.
    pub fn scan_from_buffer(&mut self, input: Vec<u8>) -> Result<&BufferState> {
        let size = input.len();
        if size < 2 || &input[size-2..=size-1] != &[END_OF_BUFFER_CHAR, END_OF_BUFFER_CHAR] {
            Err("buffer does not end in two END_OF_BUFFER_CHARs.")
        } else {
            let buffer = BufferState {
                buf_size: size - 2,
                buf_pos: 0,
                ch_buf: input,
                is_our_buffer: false,
                input_file: None,
                n_chars: size - 2,
                is_interactive: false,
                at_bol: true,
                fill_buffer: false,
                buffer_status: BufferStatus::New,
                bs_lineno: 1,
                bs_column: 0,
            };
            self.switch_to_buffer(buffer);
            Ok(self.current_buffer_unchecked())
        }
    }

    /// Setup the input buffer state to scan a string. The next call to lex() will scan from a @e
    /// copy of @a str. Note: If you want to scan a buffer that may contain NUL values, then use
    /// scan_bytes() instead.
    pub fn scan_string(&mut self, input: String) -> Result<&BufferState> {
        self.scan_bytes(input.as_bytes())
    }

    /// Setup the input buffer state to scan the given bytes. The next call to lex() will scan
    /// from a @e copy of @a bytes.
    pub fn scan_bytes<B: AsRef<[u8]>>(&mut self, input: B) -> Result<&BufferState> {
        let input: Vec<u8> = input.as_ref().iter().chain(&[END_OF_BUFFER_CHAR, END_OF_BUFFER_CHAR]).copied().collect();
        let size = input.len();
        let buffer = BufferState {
            buf_size: size - 2,
            buf_pos: 0,
            ch_buf: input,
            is_our_buffer: true,
            input_file: None,
            n_chars: size - 2,
            is_interactive: false,
            at_bol: true,
            fill_buffer: false,
            buffer_status: BufferStatus::New,
            bs_lineno: 1,
            bs_column: 0,
        };
        self.switch_to_buffer(buffer);
        Ok(self.current_buffer_unchecked())
    }
}

const END_OF_BUFFER_CHAR: u8 = 0;

/* Size of default input buffer. */
const BUF_SIZE: usize = 32768;
const READ_BUF_SIZE: usize = BUF_SIZE/2;

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
const STATE_BUF_SIZE: usize = (BUF_SIZE + 2) * std::mem::size_of::<State>();

#[derive(PartialEq, Eq)]
enum EOBAction {
    ContinueScan,
    EndOfFile,
    LastMatch,
}

macro_rules! less_lineno {
    () => {};
}
macro_rules! lineno_rewind_to {
    ( $ptr:expr ) => {};
}

macro_rules! less {
    ( $n:literal ) => {
        less_lineno!(n);
        yyg.c_buf_p[cp] = yyg.hold_char;
        restore_more_offset!();
        cp = bp + n - MORE_ADJ;
        do_before_action!();
    };
}

macro_rules! unput {
    ( $c:expr ) => { unput(c, yyg.text_ptr, yycanner); };
}

#[derive(Debug, PartialEq, Eq)]
enum BufferStatus {
    New,
    Normal,
    /** When an EOF's been seen but there's still some text to process
      * then we mark the buffer as EOF_PENDING, to indicate that we
      * shouldn't try reading from the input source any more.  We might
      * still have a bunch of tokens to match, though, because of
      * possible backing-up.
      *
      * When we actually see the EOF, we change the status to "new"
      * (via restart()), so that the user can continue scanning by
      * just pointing in at a new input file.
      */
    EOFPending,
}

pub struct BufferState {
    input_file: Option<Rc<RefCell<dyn io::Read>>>,
    /// input buffer
    ch_buf: Vec<u8>,
    /// current position in input buffer
    buf_pos: usize,

    /** Size of input buffer in bytes, not including room for EOB
      * characters.
      */
    buf_size: usize,

    /** Number of characters read into ch_buf, not including EOB
      * characters.
      */
    n_chars: usize,

    /** Whether we "own" the buffer - i.e., we know we created it,
      * and can realloc() it to grow it, and should free() it to
      * delete it.
      */
    is_our_buffer: bool,

    /** Whether this is an "interactive" input source, if so, and
      * if we're using stdio for input, then we want to use getc()
      * instead of fread(), to make sure we stop fetching input after
      * each newline.
      */
    is_interactive: bool,

    /** Whether we're considered to be at the beginning of a line.
      * If so, '^' rules will be active on the next match, otherwise
      * not.
      */
    at_bol: bool,

    /// The line count.
    bs_lineno: usize,
    /// The column count.
    bs_column: usize,

    /** Whether to try to fill the input buffer when we reach the
      * end of it.
      */
    fill_buffer: bool,

    buffer_status: BufferStatus,
}

impl BufferState {
    /// Allocate and initialize an input buffer state.
    fn new(source: Option<Rc<RefCell<dyn io::Read>>>, size: usize) -> BufferState {
        let mut b = BufferState {
            input_file: None,
            ch_buf: Vec::with_capacity(size + 2),
            buf_pos: 0,
            buf_size: size + 2,
            n_chars: 0,
            is_our_buffer: true,
            is_interactive: false,
            at_bol: false,
            bs_lineno: 1,
            bs_column: 0,
            fill_buffer: false,
            buffer_status: BufferStatus::New
        };
        b.init(source);
        b
    }

    // Initializes or reinitializes a buffer.  This function is sometimes called more than once on
    // the same buffer, such as during a restart() or at EOF.
    fn init(&mut self, source: Option<Rc<RefCell<dyn io::Read>>>) {
        self.flush();
        self.input_file = source;
        self.fill_buffer = true;
    }

    /// Discard all buffered characters. On the next scan, INPUT will be called.
    fn flush(&mut self) {
        self.n_chars = 0;

        // We always need two end-of-buffer characters.  The first causes a transition to the
        // end-of-buffer state.  The second causes a jam in that state.
        self.ch_buf.clear();
        self.ch_buf.push(END_OF_BUFFER_CHAR);
        self.ch_buf.push(END_OF_BUFFER_CHAR);

        self.buf_pos = 0;

        self.at_bol = true;
        self.buffer_status = BufferStatus::New;
    }
}

// /* Begin user sect3 */

type State = i16;

/* %% [1.5] DFA */
/* START of m4 controls */
/* M4_MODE_NO_NULTRANS */
/* M4_MODE_NO_NULTRANS_FULLTBL */
/* M4_MODE_NO_NULTRANS_FULLSPD */
/* END of m4 controls */

/* START of Flex-generated definitions */
const NUM_RULES: State = 4;
const END_OF_BUFFER: State = 5;
const JAMBASE: State = 7;
const JAMSTATE: State = 9;
const NUL_EC: u8 = 1;
type Offset = i16;
 /* END of Flex-generated definitions */

struct TransInfo {
    /* We require that verify and nxt must be of the same size int. */

    /* We generate a bogus 'struct trans_info' data type
     * so we can guarantee that it is always declared in the skel.
     * This is so we can compile "sizeof(struct trans_info)"
     * in any scanner.
     */
    verify: i32,
    nxt: i32,
}

/* %% [2.0] data tables for the DFA are inserted here */
const accept: [i16; 10] = [   0,
          0,    0,    5,    1,    2,    3,    1,    2,    0
];

const base: [i16; 12] = [   0,
         0,    0,    6,    0,    0,    7,    0,    0,    7,    4,
         2
];

const def: [i16; 12] = [   0,
         9,    1,    9,   10,   11,    9,   10,   11,    0,    9,
         9
];

const nxt: [i16; 11] = [   0,
         4,    5,    6,    8,    7,    9,    3,    9,    9,    9
];

const chk: [i16; 11] = [   0,
         1,    1,    1,   11,   10,    3,    9,    9,    9,    9
];
/* footprint: 372 bytes */

/* m4 controls begin */
/* M4_MODE_HAS_BACKING_UP */
/* M4_MODE_NEED_YY_CP */
/* m4 controls end */

/* Character equivalence-class mapping */
const ec: [u8; 256] = [ 0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1
];

/* Character meta-equivalence-class mappings */
const meta: [u8; 4] = [ 0,
         1,    2,    3
];

/** The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
macro_rules! REJECT {
    ( ($whatever:tt)* ) => { panic!("reject used but not detected"); }
}

macro_rules! more {
    ( ($whatever:tt)* ) => { panic("more used but not detected"); }
}

const MORE_ADJ: usize = 0;
const RESTORE_MORE_OFFSET: bool = false;

/* %% [3.0] static declarations conditional on mode switches go here */
/* First cut at a flex-based "wc" tool. */

const INITIAL: State = 0;

/** Number of entries by which start-condition stack grows. */
const START_STACK_INCR: usize = 25;

/* end tables serialization structures and prototypes */

fn read_interactive(buf: &mut BufferState, file: &Rc<RefCell<dyn io::Read>>, offset: usize, max_size: usize) -> Result<usize> {
    let mut n: usize = 0;
    let mut tmp: [u8; 1] = [0];
    loop {
        match file.borrow_mut().read(&mut tmp) {
            Ok(v) => {
                if v == 0 {
                    break;
                } else if v == 1 {
                    buf.ch_buf[offset + n] = tmp[0];
                    n += 1;
                }
            },
            Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,
            _ => return Result::Err("input in flex scanner failed"),
        };
        if n >= max_size {
            break;
        }
    }
    Ok(n)
}

fn read_file(buf: &mut BufferState, file: &Rc<RefCell<dyn io::Read>>, offset: usize, max_size: usize) -> Result<usize> {
    loop {
        let result = file.borrow_mut().read(&mut buf.ch_buf[offset..]);
        match result {
            Ok(v) => break Ok(v),
            Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,
            _ => return Result::Err("input in flex scanner failed"),
        };
    }
}
